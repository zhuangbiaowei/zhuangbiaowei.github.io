---
layout: post
title: 试论开源生态的经济模型
date: 2022-02-05 14:53 +0800
---

## 缘起

这是一个我一直想写，却一直没有想得非常清楚的课题。目标非常清楚：通过创建一种经济模型，来分析开源生态中的各种问题。

上一次在CHAOSS china的一档播客节目里，我们在讨论关于“指标”的问题。当时的话题是：自下而上的指标，还是自上而下的指标。

所谓自下而上，就是从开源世界原本就能观察到的各种行为入手，比如star、fork、commit、PR等等，然后通过某种计算，得到一个“指标”。这样做的问题是：意义不明。我们可以做各种加权计算，但是：为啥可以这么计算呢，无法说明。

所谓自上而下，就是从目标入手，我们希望考察一个开源项目，或者一个开源社区的某种活跃度，健康度，或者其他特征。然后去尝试构建一种计算方法：将各种行为拼接、计算。这样做的问题是：无从下手。因为我们可以提出无数的问题，但是答案太难找了。

关键在于：我们缺少一组明白无误的概念，并且这些概念能够组成一个可以理解并且切合实际的模型。更进一步的关键在于：我们对于开源软件，乃至对于开源的本质，缺乏理解。

## 从劳动价值论入手开始思考

最近我刚刚读完一本很薄的小书《[解读劳动价值理论](https://weread.qq.com/web/reader/45732a105cadfd45783b27a)》，总共只有5.9万字，却解释的非常清晰。简单的抄一下书：

**使用价值**：一种劳动产品之所以能当做商品出售，是因为它具有一定的有用性。这种产品的有用性，即能满足人们某种需要的属性，马克思称之为商品的使用价值。

**交换价值**：交换价值首先表现为一种使用价值同另一种使用价值相交换的量的关系或比例。

**交换价值（补充）**：后来（货币时代）表现为商品与货币的交换关系，即一定数量的商品交换货币的多少。

**价值**：凝结在商品中的抽象的人类劳动就是商品的价值，隐藏在商品交换价值中的共同的东西就是价值。

隐藏在商品交换关系或交换价值中的共同物——劳动量，就是商品的价值，而交换价值则是价值的表现形式。

**社会必要劳动时间**：社会必要劳动时间是在现有的社会正常生产条件下，在社会平均的劳动熟练程度下制造某种使用价值所需要的劳动时间。

使用价值是商品的自然属性，交换价值是商品的社会属性。换句话说，交换价值即价格，它相对于价值来说，总是会上下略为浮动的。

**综上所述，使用价值表示商品有什么用，价值表示商品值多少钱，但这个“钱”不是指商品价格，而是凝结在商品中的人类劳动量。**

## 通过劳动价值的系列概念，来思考软件的使用价值与价值

在马克思的时代，他所讨论的商品，都是“实物形态”的，因此：所谓交换，要么是物物交换，要么是钱物交换。但是，到了商业软件时代，可以无限复制的软件（无论是源代码，还是可执行的软件），它的价值是什么呢？

另一方面，在讨论全世界所有的商品时，不同的商品的使用价值，其实是无法比较的。但是，同样作为软件，不同的软件的使用价值，是否可以互相比较呢？

**软件的本质**，在CPU上执行的软件，本质上是在替代人类的脑力劳动。因此，软件的本质就是“人类脑力劳动能力的凝结”。

所以，**软件的使用价值**，在于能够替代多少人类的脑力劳动。因此，不同的软件的使用价值是可以互相比较的。

比如：一次100位整数乘以100位整数的乘法运算，人类的平均计算时间是多久？通过某种计算机计算，时间是多久？假设前者是1天，后者是0.1秒钟。那么，这就是这款乘法计算的软件，在一次运行之后，产生的价值。

再复杂一点的，一部3D动画片的计算机渲染，用计算机需要多少时间？耗费多少成本？用人工绘制，假设每一帧都是手绘，需要多少人，多少时间，耗费多少成本？那么，这就是3D图形渲染软件，在一部电影制作中，产生的价值。

基于我们对于软件本质的理解，一款软件的使用价值，其实取决于这款软件本身的替代能力，再乘以运行在多少台电脑（CPU）上，再乘以运行了多少次。

社会必要劳动时间，也是一种理论时间，按照我的理解，可以称之为：开发一款软件的平均成本。

于是：估算一款软件的价值，就可以换算为“估算一款软件的平均开发成本”。

这方面有两个参考，一个是过去经常听到的，基于功能点（[Function point](https://en.wikipedia.org/wiki/Function_point)）的开发成本估算，另一种是我在适兕的新书《开源之迷》里看到的，构造性成本模型（Constructive Cost Model, [COCOMO](https://en.wikipedia.org/wiki/COCOMO)）。

更多信息可以参考：[Cost estimation in software engineering](https://en.wikipedia.org/wiki/Cost_estimation_in_software_engineering)

**软件的交换价值**，本质上并非金钱与软件的交换，而是金钱与使用权的交换。正因为软件的特殊性，因此：使用权的定价，也出现为比传统实体商品，更加复杂的情况。

## 软件定价的两种模型

区分了使用价值与价值，我们就会发现，在软件领域，存在两种定价的模式。一种是基于使用价值定价，或者说基于使用情况定价。另一种则是基于价值来定价，或者说：基于社会必要劳动时间/开发成本定价。

基于使用情况定价，其实就是卖拷贝。你们公司有100个人，每个人都用我的Office软件，那么就要出100份钱。你买了我的软件，运行在一百台服务器上，每台服务器有32个核，都应该算清楚，然后付钱。

基于开发成本定价，其实就是“定制化开发”。我提需求，你报成本，最后我按照一个合理的价格付钱，你有得赚，我也省得再自己开发了。

之所以存在两种定价模式，还是在于软件的可复制性。在实体商品的情况下，每生产一份商品，都需要付出一份劳动。因此：社会必要劳动时间-->价值-->使用价值，一个紧密连接的整体。而在数字商品的情况下，可以无限复制的软件/数字商品，具有近乎无限可能性的使用价值。而其社会必要劳动时间，以及由此所确定的价值，却是有限的。

## 现代软件生态中的使用价值

在过去（几十年前），软件就是软件，软件复用还只一种理想。但是到了现在，现代编程语言的发展，诞生了“基于包管理系统”的软件开发复用模式。

于是，一个可以直接使用的最终软件与一个可以被复用的软件包，变成了两个概念。通常在一个最终软件里，都会包含（依赖）非常多的软件包，而一个较为流行的开源软件包，也会被很多不同的软件所采用（依赖）。

当我们想要估算一款开源软件包的使用价值时，会变得非常困难。A使用了B，B使用了C、D，D又使用了E。如果我们经过充分的统计，也许最终会搞清楚：E，同时被4种不同的软件，在不同情况的下使用了。

当然，我们还需要了解：这些不同的软件，运行在多少台电脑（CPU）上，以及运行了多少次。如果是商业软件，也许还能通过销售来掌握数据，但是对于开源软件，那就太难了。

## 开源社区活跃度的意义？

因为无法实际统计，一款开源软件的实际使用情况。我们只能借助一个假设：“越是用户众多的开源软件，开源社区的活跃度也会越高”。

当然：这样的假设会存在很多的不确定性。

1. 越是成熟的软件，用户虽多，但用户在社区的活跃度却可能越低
2. 用户数量与使用数量的关系，取决于这款开源软件的应用领域，越是服务器端的，底层的软件，也是少数管理员，维护大量使用的实例
3. 因为包依赖的关系，导致大量间接使用，却无法带来活跃度的提升

所以，计算某一开源社区的活跃度，无法等价于“这个开源软件的使用价值”。

## 价值流网络的意义

赵生宇（Frank）最近写了三篇博客，也在讨论相关的话题。

* [如何评价一个开源项目（一）——活跃度](http://blog.frankzhao.cn/how_to_measure_open_source_1)
* [如何评价一个开源项目（二）——协作影响力](http://blog.frankzhao.cn/how_to_measure_open_source_2)
* [如何评价一个开源项目（三）——价值流网络](http://blog.frankzhao.cn/how_to_measure_open_source_3)

在我看来，价值流网络，其实就是在开源软件生态的复杂网络中，借助PageRank的算法，尽可能“推演”出一款开源软件的**使用价值**。

这当然是非常有价值的工作，但是这并没有解决开源软件的**价值**，或者说：**社会必要劳动时间**的计算问题。

## 开源社区中的各种时间花费

在开源社区中产生的各种行为，都会有其行为发起方与参与方，花费各自的时间。这些时间，有些是典型的软件开发过程中，正常花费。另外一些，则是社区里才会存在的行为与花费的时间。

比如：合理的提问，与正常的解答。如果能够将问答内容沉淀下来，本来就会节约后来者的时间。但是，如果有用户，毫无搜索与查找能力，直接提问，且强行占用他人的时间。这种行为，就会被社区所唾弃。因为，他浪费了整个社区的有效投入时间。

于是，在任何情况下，我们可以看到三个时间长度。

* T1 = 当前版本，从头开发，所需的必要劳动时间。
* T2 = 当前版本，从一开始到现在，社区整体投入的劳动时间。
* T3 = 当前版本，从一个开始到现在，整个社区全体成员，所花费的时间

通常 T1 < T2 < T3

我们可以将 T1/T2 的比例，理解为社区的开发能力（少走弯路的能力）；T2/T3 的比例，理解为社区的治理能力（少受打扰的能力）。当然还可以再引申：比如处理bug的时间，占开发时间的比例，代表着开源软件的质量。

## 如何估算社区中的行为耗时

上一小节中，T1的时间看起来还比较容易估算。也许基于功能点，也许采用COCOMO。但是T2和T3呢？其实，我们应该能理解，越是复杂的行为，越是难以估算其平均耗时。而越是简单的行为，就越容易估算。

比如：写一个100万行代码的软件，社会必要劳动时间就很难估算。但是：写一个Class中的get/set方法，耗时就非常容易估算。写100万字的一本小说，社会必要劳动时间会很难估算（起点中文网，也许已经有很准确的数据了），但是：写一个100行的文档，耗时就非常容易估算了。

同样的，我们在开源社区观察到的很多行为，无论是点赞，fork，创建issue，还是发起一个PR，都比完整的写一个软件，要简单很多。相对而言，估算其平均耗时，也会更加容易。

## 开源社区活跃度的计算方法

如果我们将开源社区活跃度，定义为：一个开源社区，从全世界范围内，吸引到的总时间投入，再除以单位时间。较之纯粹主观的将各种行为加权运算，就会变得更加有解释力了。

假设点击一个star，需要花费一个用户1秒钟的时间。fork一个仓库，大约2~3秒钟。

提交一个issue，就不能按一条issue来算，而应该计算写这个issue，花了多少时间。在写issue之前的时间，我们无法计算（调试bug，各种碰壁），写作的时间，也许是 1个单词2、3秒钟。然后，围绕这个issue，不断的有人查看，有人参与讨论，直到最后这个issue被关闭。总共大约花费了30~60分钟的时间，甚至更多。

写代码，提交PR，也可以按照类似的思路计算。

从这个角度来看，star的权重是秒级的，而issue，PR的权重，应该是分钟，甚至小时级的。这样计算活跃度，才会更加合理。

## 开源社区活跃度的意义！

我们可以认为，全人类的所有可使用的时间，是一个很大的常数。各个开源社区，当然还有互联网、SNS、短视频和购物平台，都在争夺这些时间与注意力。

全世界的程序员，能够投入写代码，写文档，回答问题，调试bug的总时间，其实是有限的。一个开源社区能够吸引到足够多的注意力与时间投入，就是其成功的基础保证。而软件/互联网企业之间的开源竞争，其实就是在争夺程序员们的注意力，剩余时间。这也正是我在多年以前提到的关键点：《[开源项目也要讲注意力经济](/thinking/it/2015/03/11/Open-source-attention-economy.html)》

## 对于协作影响力的改进

在Frank的博客中，假设开发者 d 在项目 p1 上活跃度为 Ad,p1，在项目 p2 上的活跃度为 Ad,p2，则该开发者对这两个项目协作关联度的贡献为 (Ad,p1 * Ad,p2)/(Ad,p1 + Ad,p2)。

在问题部分，Frank也写道：“开源协作网络的设计对活跃度虽然不敏感，但却有要求。即如果活跃度中引入 star 或 fork 这类低成本的行为，会导致大量项目之间产生连接关系，进而导致对项目类别判断的准确率下降。也就说目前聚类的效果很大程度上依赖于底层的活跃度设计。”

因此，我的建议就一条：采用基于时间的活跃度设计，来计算协作影响力。 :P

## 总结

通过以上的分析，我们基本上可以得到一个开源生态的经济模型的全貌了。

* 社会必要劳动时间  -->  特定版本的开发成本 --> T1 --> 特定版本的价值
* 社区总投入时间 --> 开源社区活跃度 --> T3 --> 社区竞争力
* 基于时间投入的协作影响力 --> 开源社区之间的相关度 --> PageRank --> 生态关联度
* 价值流网络 --> 开源软件的生态总价值 --> 使用价值

基于以上的模型，我们也许可以展开进一步的分析了。